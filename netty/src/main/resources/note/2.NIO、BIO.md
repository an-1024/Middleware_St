# 网络 Socket
Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口，一般由操作系统提供。它是一组接口，应用层只需要使用这个接口提供的 api 即可
完成 TCP/IP 的操作。

客户端连接上一个服务端，就会在客户端中产生一个 socket 接口实例，服务端每接受 一个客户端连接，就会产生一个 socket 接口实例和客户端的 
socket 进行通信，有多个客户 端连接自然就有多个 socket 接口实例。

## 长连接
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 长连接指建立 SOCKET 连接后不管是否使用都保持连接。

## 短连接
连接->传输数据->关闭连接：传统 HTTP 是无状态的，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。
也可以这样说: 短连接是指 SOCKET 连接后发送后接收完数据后马上断开连接。

在通信编程中关注的其实也就是三个事情:
1. 连接(客户端连接服务器，服务器等 待和接收连接);
2. 读网络数据;
3. 写网络数据;

所有模式的通信编程都是围绕着这三件事情进行的。服务端提供 IP 和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，
如果连接成功建立，双方就可以通过套接字进行通信。

# Java 原生网络编程-BIO
BIO，意为 Blocking I/O，即阻塞的 I/O。在 BIO 中类 ServerSocket 负责绑 定 IP 地址，启动监听端口，等待客户连接;客户端 Socket 类的实例
发起连接操作，ServerSocket 接受连接后产生一个新的服务端 socket 实例负责和客户端 socket 实例通过输入和输出流进行通信。

编写一个 Socket demo 测试一下：

Server 端
```java
public class WebSocketServiceDemo {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket accept = null;
        try {
            serverSocket = new ServerSocket();
            // 绑定监听端口
            serverSocket.bind(new InetSocketAddress(20001));
            System.out.println("Server start with Port: 20001");
            int count = 0;
            while (true) {
                // 监听连接, 建立连接实例
                accept = serverSocket.accept();
                System.out.println("accept client socket.....total = " + (++count));

                // 实例化与客户端的输入输出流
                try (ObjectInputStream inputStream = new ObjectInputStream(accept.getInputStream());
                     ObjectOutputStream outputStream = new ObjectOutputStream(accept.getOutputStream())) {
                    
                    // 接收客户端的输出
                    String message = inputStream.readUTF();
                    System.out.println("accept client message:" + message);
                    
                    // 服务端输出信息
                    outputStream.writeUTF("hello" + message);
                    outputStream.flush();
                }

            }
        } catch (Exception e) {
            // doNothing
        }finally {
            try {
                if(!Objects.isNull(serverSocket)) {
                    serverSocket.close();
                }
                
                if (!Objects.isNull(accept)){
                    accept.close();
                }
            }catch (Exception e){
                // doNothing
            }
        }
    }
}
```

Client 端
```java
public class WebSocketClientDemo {
    public static void main(String[] args) {
        // 创建 socket 对象
        Socket socket = null;
        // 创建输入输出流
        ObjectOutputStream outputStream = null;
        ObjectInputStream inputStream = null;
        // 服务器的通讯地址
        InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 20001);
        try {
            socket = new Socket();
            // 连接服务器
            socket.connect(inetSocketAddress);
            System.out.println("connect Server success");
            outputStream = new ObjectOutputStream(socket.getOutputStream());
            inputStream = new ObjectInputStream(socket.getInputStream());

            System.out.println("ready send message");
            // 向服务器输出信息
            outputStream.writeUTF("Java");
            outputStream.flush();

            // 接收服务器的信息
            System.out.println("receive message from server: " + inputStream.readUTF());
        } catch (Exception e) {
            // doNothing
        } finally {
            try {
                if (!Objects.isNull(socket)) {
                    socket.close();
                }

                if (!Objects.isNull(outputStream)) {
                    outputStream.close();
                }
                
                if(!Objects.isNull(inputStream)) {
                    inputStream.close();
                }
            } catch (IOException e) {

            }
        }
    }
}
```
然后启动服务端，在客户端`outputStream.writeUTF("Java");` 打上断点，debug 启动，此时服务端输出信息；
```text
Server start with Port: 20001
accept client socket.....total = 1
```
接着再启动一个客户端程序，发现虽然第二个客户端连接成功了，客户端输出信息如下：
```text
connect Server success
```
但是服务端却并没有任何输出。这就是 BIO 的阻塞。因为第一个客户端的阻塞，导致服务端并没有从操作系统中获取到新的连接，应用层没有感知，从而导致
服务端一直在处理第一个客户端，结果导致第二个客户端也阻塞。当第一个客户端继续运行，第二个客户端也随之执行完成。输出结果：
```text
Server start with Port: 20001
accept client socket.....total = 1
accept client message:Java
accept client socket.....total = 2
accept client message:Java
```
因此我们可以在服务端采用多线程接收连接：
```java
/**
 *  多线程的 Socket 服务
 */
public class WebSocketServicThreadDemo {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket accept = null;
        try {
            serverSocket = new ServerSocket();
            // 绑定监听端口
            serverSocket.bind(new InetSocketAddress(20001));
            System.out.println("Server start with Port: 20001");
            int count = 0;
            while (true) {
                // 监听连接, 建立连接实例
                accept = serverSocket.accept();
                System.out.println("accept client socket.....total = " + (++count));

                // 实例化与客户端的输入输出流
                new Thread(new ServerTask(accept)).start();
            }
        } catch (Exception e) {
            // doNothing
        }finally {
            try {
                if(!Objects.isNull(serverSocket)) {
                    serverSocket.close();
                }
                
                if (!Objects.isNull(accept)){
                    accept.close();
                }
            }catch (Exception e){
                // doNothing
            }
        }
    }
    
    private static class ServerTask implements Runnable{
        
        private Socket socket;
        public ServerTask (Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            ObjectInputStream inputStream = null;
            ObjectOutputStream outputStream = null;
            try {
                inputStream = new ObjectInputStream(socket.getInputStream());
                outputStream = new ObjectOutputStream(socket.getOutputStream());

                // 接收客户端的输出
                String message = inputStream.readUTF();
                System.out.println("accept client message:" + message);

                // 服务端输出信息
                outputStream.writeUTF("hello" + message);
                outputStream.flush();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                try {
                    if(!Objects.isNull(inputStream)) {
                        inputStream.close();
                    }
                    
                    if(!Objects.isNull(outputStream)) {
                        outputStream.close();
                    }
                }catch (Exception e){
                    // doNothing
                }
            }
        }
    }
}
```
尽管服务不再阻塞，但是每建立一个连接都需要创建一个线程，当有几万个客户端，那就需要创建几万个线程，最终导致系统挂掉。这显然是不可取的。

第三版，使用线程池：
```java
/**
 *  线程池 Socket 服务
 */
public class WebSocketServicThreadPoolDemo {

    private static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket accept = null;
        try {
            serverSocket = new ServerSocket();
            // 绑定监听端口
            serverSocket.bind(new InetSocketAddress(20001));
            System.out.println("Server start with Port: 20001");
            int count = 0;
            while (true) {
                // 监听连接, 建立连接实例
                accept = serverSocket.accept();
                System.out.println("accept client socket.....total = " + (++count));

                // 实例化与客户端的输入输出流
                executorService.execute(new ServerTask(accept));
            }
        } catch (Exception e) {
            // doNothing
        }finally {
            try {
                if(!Objects.isNull(serverSocket)) {
                    serverSocket.close();
                }

                if (!Objects.isNull(accept)){
                    accept.close();
                }
            }catch (Exception e){
                // doNothing
            }
        }
    }

    private static class ServerTask implements Runnable{

        private Socket socket;
        public ServerTask (Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            ObjectInputStream inputStream = null;
            ObjectOutputStream outputStream = null;
            try {
                inputStream = new ObjectInputStream(socket.getInputStream());
                outputStream = new ObjectOutputStream(socket.getOutputStream());

                // 接收客户端的输出
                String message = inputStream.readUTF();
                System.out.println("accept client message:" + message);

                // 服务端输出信息
                outputStream.writeUTF("hello" + message);
                outputStream.flush();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                try {
                    if(!Objects.isNull(inputStream)) {
                        inputStream.close();
                    }

                    if(!Objects.isNull(outputStream)) {
                        outputStream.close();
                    }
                }catch (Exception e){
                    // doNothing
                }
            }
        }
    }
}
```
尽管避免了大量线程的创建，但是正因为限制了线程数量，如果发生读取数据较慢时(比如数据量大、网络传 输慢等)，大量并发的情况下，其他接入的消息，
只能一直等待，这就是最大的弊端。

# Java 原生网络编程-NIO
NIO 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 IO 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。NIO 被称为 no-blocking io 
或者 new io 都说得通。

## 和 BIO 的主要区别
Java NIO 和 IO 之间第一个最大的区别是，BIO 是面向流的，NIO 是面向缓冲区的。 
1. Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方; 因此，它不能前后移动流中的数据；
2. Java NIO 的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动；

## 阻塞与非阻塞 IO
Java IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此
期间不能再干任何事情了。

Java NIO 的非阻塞模式：
> 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞。非阻塞写也是如此。

## NIO 的模式-Reactor
具体事件处理程序不调用反应器，反而向反应器注册一个事件处理器，表示自己对某些事件感兴趣，有事件来了，具体事件处理程序通过事件处理器对某个指
定的事件发生做出反应; 这种控制逆转又称为“好莱坞法则”(不要调用我，让我来调用你)

## NIO 的三大组件关系
NIO 有三大核心组件:Selector 选择器、Channel 管道、buffer 缓冲区。

## Selector
Selector 的英文含义是“选择器”，也可以称为为“轮询代理器”、“事件订阅器”、“channel 容器管理机”都行。

Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器(Selectors)，然后使用一个单独的线程来操作这个选
择器，进而“选择”通道: 这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

应用程序将向 Selector 对象注册需要它关注的 Channel，以及具体的某一个 Channel 会 对哪些 IO 事件感兴趣。Selector 中也会维护一个“已经注册
的 Channel”的容器。

## Channels
通道：被建立的一个应用程序和操作系统交互事件、传递内容的渠道(注意是连接到操作系统)。那么既然是和操作系统进行内容的传递，那么说明应用程序可
以通过通道读取数据，也可以通过通道向操作系统写数据，而且可以同时进行读写。
1. 所有被 Selector(选择器)注册的通道，只能是继承了 SelectableChannel 类的子类;
2. ServerSocketChannel:应用服务器程序的监听通道。只有通过这个通道，应用程序才 能向操作系统注册支持“多路复用 IO”的端口监听。同时支持 
UDP 协议和 TCP 协议。
3. ScoketChannel:TCP Socket套接字的监听通道，一个Socket套接字对应了一个客户端 IP: 端口到服务器 IP:端口的通信连接。
> 通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。

## buffer 缓冲区
我们前面说过 JDK NIO 是面向缓冲的。Buffer 就是这个缓冲，用于和 NIO 通道进行交互。数据是从通道读入缓冲区，从缓冲区写入到通道中的。
缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存(其实就是数组)。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。

# 代码实现







