# Redis 分布式锁
先看一段模拟扣减库存的代码
```java
@RestController
public class RedisLockController {
    
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock() {
        synchronized (this) {
            // 提前在redis服务上设置 300 个库存
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                // 重新设置缓存
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减库存成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减库存失败，库存不足");
            }
            return String.valueOf(stock);
        }
    }
}
```
这段代码在单机的情况下是没问题的。但是目前的系统架构基本都是微服务多机，而 synchronized 锁是基于 JVM 级别，只能在当前机器中生效，多机环境下，
在高并发的情况下，这段代码是有问题的。

配置 nginx 代理，修改配置文件
```text
    upstream redislock{  # 代理的地址(物理机网卡 ip)
        server 192.168.0.200:8080 weight=1;
        server 192.168.0.200:8090 weight=1;
    }

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
            proxy_pass  http://redislock;  # 代理的路径
        }
```

配置好后重新启动 nginx
```shell
nginx -s reload
```

然后配置不同的端口号，启动两个相同的服务，通过链接[扣减库存](http://10.211.55.3/deduct_stock) 访问服务，看看 nginx 是否代理生效(会将请求分发
到不同的服务器上)。测试结果：
```text
2023-03-07 10:11:41.371  INFO 59969 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2023-03-07 10:11:41.378  INFO 59969 --- [           main] c.anzhi.redislock.RedisLockApplication   : Started RedisLockApplication in 1.116 seconds (JVM running for 1.694)
2023-03-07 10:11:45.292  INFO 59969 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2023-03-07 10:11:45.293  INFO 59969 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2023-03-07 10:11:45.296  INFO 59969 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 3 ms
扣减库存成功，剩余库存：299
扣减库存成功，剩余库存：298
扣减库存成功，剩余库存：297


2023-03-07 19:30:01.061  INFO 62217 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8090 (http) with context path ''
2023-03-07 19:30:01.069  INFO 62217 --- [           main] c.anzhi.redislock.RedisLockApplication   : Started RedisLockApplication in 1.546 seconds (JVM running for 2.193)
2023-03-07 19:45:11.877  INFO 62217 --- [nio-8090-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2023-03-07 19:45:11.877  INFO 62217 --- [nio-8090-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2023-03-07 19:45:11.882  INFO 62217 --- [nio-8090-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 5 ms
扣减库存成功，剩余库存：296
```

接下来使用 jmeter 模拟高并发来压测一下这段代码的问题：
1. 下载 Jmeter: [下载地址](https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.5.tgz)
2. 下载完成之后，进行解压,然后为 jmeter 配置环境变量
```shell
# Jmeter Config
export JMETER_HOME=/Users/azh/Dev_AZH/Java_Env/apache-jmeter-5.5
# 配置环境生效
export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin:$GRADLE_HOME/bin:$GH_MD_TOC/:$JMETER_HOME/bin

# 配置完成后保存，退出，使环境变量生效
source ~/.bash_profile

# 启动 Jmeter
jmeter
```
启动成功后会弹出一个 Jmeter 的操作界面，然后开始配置我们的压测：
![压测配置-1](../photo/3.Jmeter压测配置-1.png)
![压测配置-2·](../photo/3.Jmeter压测配置-2.png)
具体页面配置如下：
![请求配置页面](../photo/3.Jmeter压测配置-3.png)
![线程压测页面](../photo/3.Jmeter压测配置-4.png)
在压测的时候尽量选择一个压测报告，可以实时监控压测的情况：
![压测报告](../photo/3.Jmeter压测配置-5.png)

点击绿色运行按钮，开始压测，第一次需要你保存压测计划，保存完成之后，压测就开始了，下图是压测报告

8080 服务终端部分输出结果：
```text
扣减库存成功，剩余库存：299
扣减库存成功，剩余库存：298
扣减库存成功，剩余库存：297
扣减库存成功，剩余库存：294
扣减库存成功，剩余库存：293
扣减库存成功，剩余库存：291
扣减库存成功，剩余库存：290
扣减库存成功，剩余库存：287
扣减库存成功，剩余库存：286
扣减库存成功，剩余库存：284
扣减库存成功，剩余库存：283
扣减库存成功，剩余库存：281
扣减库存成功，剩余库存：278
扣减库存成功，剩余库存：277
扣减库存成功，剩余库存：276
扣减库存成功，剩余库存：274
```

8090 服务终端输出结果：
```text
扣减库存成功，剩余库存：296
扣减库存成功，剩余库存：295
扣减库存成功，剩余库存：294
扣减库存成功，剩余库存：293
扣减库存成功，剩余库存：292
扣减库存成功，剩余库存：291
扣减库存成功，剩余库存：290
扣减库存成功，剩余库存：289
扣减库存成功，剩余库存：288
扣减库存成功，剩余库存：287
扣减库存成功，剩余库存：286
扣减库存成功，剩余库存：285
扣减库存成功，剩余库存：284
扣减库存成功，剩余库存：283
扣减库存成功，剩余库存：282
扣减库存成功，剩余库存：281
```

仔细观察结果就会发现会有重复的库存出现。证明了 Synchronized 锁是无法保证多机情况下的并发安全。


## Redis 缓存数据冷热分离
1. 基本的冷热分离方案：针对于经常查询的数据，以商品为列。可以在将商品加入缓存的时候设置一个延期时间，每次查询一次就延长一次再缓存中的时间，
这样就会逐渐将热点数据和冷门儿数据慢慢地分离出来；