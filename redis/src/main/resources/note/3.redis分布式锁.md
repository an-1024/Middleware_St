# Redis 分布式锁
先看一段模拟扣减库存的代码
```java
@RestController
public class RedisLockController {
    
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock() {
        synchronized (this) {
            // 提前在redis服务上设置 300 个库存
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                // 重新设置缓存
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减库存成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减库存失败，库存不足");
            }
            return String.valueOf(stock);
        }
    }
}
```
这段代码在单机的情况下是没问题的。但是目前的系统架构基本都是微服务多机，而 synchronized 锁是基于 JVM 级别，只能在当前机器中生效，多机环境下，
在高并发的情况下，这段代码是有问题的。

配置 nginx 代理，修改配置文件
```text
    upstream redislock{  # 代理的地址(物理机网卡 ip)
        server 192.168.0.200:8080 weight=1;
        server 192.168.0.200:8090 weight=1;
    }

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
            proxy_pass  http://redislock;  # 代理的路径
        }
```

配置好后重新启动 nginx
```shell
nginx -s reload
```

然后配置不同的端口号，启动两个相同的服务，通过链接[扣减库存](http://10.211.55.3/deduct_stock) 访问服务，看看 nginx 是否代理生效(会将请求分发
到不同的服务器上)。测试结果：
```text
2023-03-07 10:11:41.371  INFO 59969 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2023-03-07 10:11:41.378  INFO 59969 --- [           main] c.anzhi.redislock.RedisLockApplication   : Started RedisLockApplication in 1.116 seconds (JVM running for 1.694)
2023-03-07 10:11:45.292  INFO 59969 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2023-03-07 10:11:45.293  INFO 59969 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2023-03-07 10:11:45.296  INFO 59969 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 3 ms
扣减库存成功，剩余库存：299
扣减库存成功，剩余库存：298
扣减库存成功，剩余库存：297


2023-03-07 19:30:01.061  INFO 62217 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8090 (http) with context path ''
2023-03-07 19:30:01.069  INFO 62217 --- [           main] c.anzhi.redislock.RedisLockApplication   : Started RedisLockApplication in 1.546 seconds (JVM running for 2.193)
2023-03-07 19:45:11.877  INFO 62217 --- [nio-8090-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2023-03-07 19:45:11.877  INFO 62217 --- [nio-8090-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2023-03-07 19:45:11.882  INFO 62217 --- [nio-8090-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 5 ms
扣减库存成功，剩余库存：296
```

接下来使用 jmeter 模拟高并发来压测一下这段代码的问题：
首先下载 Jmeter
## Redis 缓存数据冷热分离
1. 基本的冷热分离方案：针对于经常查询的数据，以商品为列。可以在将商品加入缓存的时候设置一个延期时间，每次查询一次就延长一次再缓存中的时间，
这样就会逐渐将热点数据和冷门儿数据慢慢地分离出来；